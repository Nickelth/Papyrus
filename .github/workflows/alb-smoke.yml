name: Papyrus Smoke
on: workflow_dispatch
permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  VPC_ID: ${{ secrets.VPC_ID }}
  PUBLIC_SUBNET_IDS_JSON: ${{ secrets.PUBLIC_SUBNET_IDS }}
  ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
  ECS_SERVICE: ${{ vars.ECS_SERVICE }}
  CONTAINER_PORT: ${{ vars.CONTAINER_PORT }}

jobs:
  smoke:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: AWS creds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Preflight App Health Check
        run: |
          python - <<'PY'
          from papyrus.preflight_app import create_app_skeleton

          app = create_app_skeleton()
          routes = sorted([r.rule for r in app.url_map.iter_rules()])
          print("ROUTES:", routes)

          assert "/dbcheck" in routes, "dbcheck missing"
          assert "/healthz" in routes, "healthz missing"
          PY
          
      - name: Preflight and connection information drift detection
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail

          SEC_JSON=$(aws secretsmanager get-secret-value \
            --secret-id papyrus/prd/db \
            --region "$AWS_REGION" \
            --query SecretString \
            --output text)

          EP=$(aws rds describe-db-instances \
            --db-instance-identifier papyrus-pg16-dev \
            --region "$AWS_REGION" \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text)

          PORT=$(aws rds describe-db-instances \
            --db-instance-identifier papyrus-pg16-dev \
            --region "$AWS_REGION" \
            --query 'DBInstances[0].Endpoint.Port' \
            --output text)

          SEC_HOST=$(echo "$SEC_JSON" | jq -r .host)
          SEC_PORT=$(echo "$SEC_JSON" | jq -r .port)

          echo "[INFO] SEC_HOST=$SEC_HOST RDS_HOST=$EP"
          echo "[INFO] SEC_PORT=$SEC_PORT RDS_PORT=$PORT"

          test "$SEC_HOST" = "$EP"   || { echo "FATAL: RDS endpoint drift"; exit 1; }
          test "$SEC_PORT" = "$PORT" || { echo "FATAL: RDS port drift"; exit 1; }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5
          terraform_wrapper: false

      - name: Write tfvars (runtime only)
        working-directory: infra/20-alb
        run: |
          cat > dev.auto.tfvars <<'TFV'
          vpc_id            = ${{ env.VPC_ID }}
          public_subnet_ids = ${{ env.PUBLIC_SUBNET_IDS_JSON }}
          container_port    = 5000
          allow_cidrs       = ["0.0.0.x/0"]
          ecs_tasks_sg_id   = "${{ secrets.ECS_TASK_SG_ID }}"
          TFV

      - name: Terraform apply (ALB/TG only)
        working-directory: infra/20-alb
        env:
          TF_IN_AUTOMATION: "1"
        run: |
          terraform init -input=false -upgrade=false
          terraform validate
          terraform apply -auto-approve -var-file=dev.auto.tfvars

      - name: Export outputs
        id: outs
        working-directory: infra/20-alb
        run: |
          set -euo pipefail

          ALB_DNS=$(terraform output -raw alb_dns_name)
          TG_ARN=$(terraform output -raw tg_arn)
          ALB_SG=$(terraform output -raw alb_sg_id)
          TASK_SG="${{ secrets.ECS_TASK_SG_ID }}"

          test -n "$ALB_SG"  || { echo "FATAL: alb_sg_id empty"; exit 1; }
          test -n "$TASK_SG" || { echo "FATAL: task_sg_id empty (check secret ECS_TASK_SG_ID)"; exit 1; }

          echo "alb_dns=$ALB_DNS"    >> $GITHUB_OUTPUT
          echo "tg_arn=$TG_ARN"      >> $GITHUB_OUTPUT
          echo "alb_sg_id=$ALB_SG"   >> $GITHUB_OUTPUT
          echo "task_sg_id=$TASK_SG" >> $GITHUB_OUTPUT

      - name: Resolve ALB and listener ARNs
        id: albinfo
        run: |
          set -euo pipefail
          DNS="${{ steps.outs.outputs.alb_dns }}"
          # DNS から ALB ARN を引く
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?DNSName=='$DNS'].LoadBalancerArn" \
            --output text)
          test -n "$ALB_ARN" || { echo "[FATAL] ALB ARN not found by DNS=$DNS"; exit 1; }
          echo "alb_arn=$ALB_ARN" >> $GITHUB_OUTPUT

          # 既存の HTTP:80 リスナーを探す（無ければ空文字）
          LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn "$ALB_ARN" \
            --query "Listeners[?Protocol=='HTTP' && Port==\`80\`][0].ListenerArn" \
            --output text 2>/dev/null || true)
          if [ "$LISTENER_ARN" = "None" ] || [ -z "$LISTENER_ARN" ]; then
            LISTENER_ARN=""
          fi
          echo "listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT
          echo "[INFO] ALB_ARN=$ALB_ARN LISTENER_ARN=${LISTENER_ARN:-<none>}"

      - name: Save outputs artifact
        uses: actions/upload-artifact@v4
        with:
          name: alb-outputs
          path: |
            infra/20-alb/terraform.tfstate

      - name: Resolve ECS task IP
        run: |
          set -euo pipefail

          TASK_ARN=$(aws ecs list-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --service-name "${{ env.ECS_SERVICE }}" \
            --desired-status RUNNING \
            --query 'taskArns[0]' \
            --output text)

          echo "TASK_ARN=$TASK_ARN"

          ENI_ID=$(aws ecs describe-tasks \
            --cluster "${{ env.ECS_CLUSTER }}" \
            --tasks "$TASK_ARN" \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)

          echo "ENI_ID=$ENI_ID"

          TASK_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids "$ENI_ID" \
            --query 'NetworkInterfaces[0].PrivateIpAddress' \
            --output text)

          echo "TASK_IP=$TASK_IP"

          {
            echo "task_arn=$TASK_ARN"
            echo "eni_id=$ENI_ID"
            echo "task_ip=$TASK_IP"
          } >> $GITHUB_OUTPUT

      - name: ECS task inspect (get IP and SG)
        id: ecsinfo
        run: |
          set -euo pipefail
          CLUSTER="papyrus-ecs-prd"
          SERVICE="papyrus-task-service"
          REGION="${{ env.AWS_REGION }}"

          TASK_ARN=$(aws ecs list-tasks \
            --cluster "$CLUSTER" \
            --service-name "$SERVICE" \
            --desired-status RUNNING \
            --region "$REGION" \
            --query 'taskArns[0]' \
            --output text)

          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
            echo "[FATAL] no RUNNING task found" >&2
            exit 1
          fi

          ENI_ID=$(aws ecs describe-tasks \
            --cluster "$CLUSTER" \
            --tasks "$TASK_ARN" \
            --region "$REGION" \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)

          TASK_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids "$ENI_ID" \
            --region "$REGION" \
            --query 'NetworkInterfaces[0].PrivateIpAddress' \
            --output text)

          ECS_TASK_SG=$(aws ec2 describe-network-interfaces \
            --network-interface-ids "$ENI_ID" \
            --region "$REGION" \
            --query 'NetworkInterfaces[0].Groups[0].GroupId' \
            --output text)

          echo "task_arn=$TASK_ARN"        >> $GITHUB_OUTPUT
          echo "task_ip=$TASK_IP"          >> $GITHUB_OUTPUT
          echo "ecs_task_sg=$ECS_TASK_SG"  >> $GITHUB_OUTPUT

      - name: Authorize ALB -> ECS task SG ingress
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          ALB_SG="${{ steps.outs.outputs.alb_sg_id }}"
          ECS_TASK_SG="${{ steps.ecsinfo.outputs.ecs_task_sg }}"

          echo "[INFO] authorizing $ALB_SG -> $ECS_TASK_SG tcp/5000"

          set +e
          OUT=$(aws ec2 authorize-security-group-ingress \
            --group-id "$ECS_TASK_SG" \
            --region "$REGION" \
            --ip-permissions "IpProtocol=tcp,FromPort=5000,ToPort=5000,UserIdGroupPairs=[{GroupId=$ALB_SG}]" \
            2>&1)
          RC=$?
          set -e

          if [ $RC -ne 0 ]; then
            echo "$OUT" | grep -q 'InvalidPermission.Duplicate'
            if [ $? -eq 0 ]; then
              echo "[WARN] ingress already existed, continuing"
            else
              echo "$OUT" >&2
              echo "[FATAL] unexpected error from authorize-security-group-ingress (code $RC)" >&2
              exit $RC
            fi
          else
            echo "[INFO] ingress created"
          fi

      - name: Register target
        run: |
          set -euo pipefail
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"
          TASK_IP="${{ steps.ecsinfo.outputs.task_ip }}"
          PORT="${{ env.CONTAINER_PORT }}"

          echo "Registering $TASK_IP:$PORT to $TG_ARN"

          aws elbv2 register-targets \
            --target-group-arn "$TG_ARN" \
            --targets "Id=$TASK_IP,Port=$PORT"

      - name: Ensure listener forwards to our TG
        run: |
          set -euo pipefail
          ALB_ARN="${{ steps.albinfo.outputs.alb_arn }}"
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"

          # 1) まず既存のHTTP:80リスナーを探す（あれば使う）
          LSN=$(aws elbv2 describe-listeners \
            --load-balancer-arn "$ALB_ARN" \
            --query "Listeners[?Protocol=='HTTP' && Port==\`80\`][0].ListenerArn" \
            --output text 2>/dev/null || true)
          [ "$LSN" = "None" ] && LSN=""

          if [ -z "$LSN" ]; then
            echo "[INFO] No HTTP:80 listener. Trying to create."
            set +e
            CREATE_OUT=$(aws elbv2 create-listener \
              --load-balancer-arn "$ALB_ARN" \
              --protocol HTTP --port 80 \
              --default-actions "Type=forward,TargetGroupArn=$TG_ARN" 2>&1)
            RC=$?
            set -e
            if [ $RC -eq 0 ]; then
              LSN=$(echo "$CREATE_OUT" | jq -r '.Listeners[0].ListenerArn' 2>/dev/null || true)
              echo "[INFO] Created listener: $LSN"
            else
              echo "$CREATE_OUT" | grep -q "DuplicateListener"
              if [ $? -eq 0 ]; then
                echo "[WARN] DuplicateListener: fetching existing listener on :80"
                # 競合した＝既にある。取り直して使う。
                LSN=$(aws elbv2 describe-listeners \
                  --load-balancer-arn "$ALB_ARN" \
                  --query "Listeners[?Protocol=='HTTP' && Port==\`80\`][0].ListenerArn" \
                  --output text)
                [ "$LSN" = "None" ] && { echo "[FATAL] failed to resolve existing listener after DuplicateListener"; exit 1; }
              else
                echo "$CREATE_OUT" >&2
                exit $RC
              fi
            fi
          else
            echo "[INFO] Found existing HTTP:80 listener: $LSN"
          fi

          # 2) 既存/新規どちらでも、デフォルトアクションが我々のTGを向くように修正
          CUR_TG=$(aws elbv2 describe-listeners --listener-arn "$LSN" \
            --query 'Listeners[0].DefaultActions[0].ForwardConfig.TargetGroups[0].TargetGroupArn' \
            --output text 2>/dev/null || true)

          if [ "$CUR_TG" != "$TG_ARN" ]; then
            echo "[INFO] Modifying listener to forward to TG=$TG_ARN"
            aws elbv2 modify-listener \
              --listener-arn "$LSN" \
              --default-actions "Type=forward,TargetGroupArn=$TG_ARN" >/dev/null
          else
            echo "[INFO] Listener already forwards to our TG"
          fi

          # 参考出力（証跡）
          aws elbv2 describe-listeners --listener-arn "$LSN" \
            --query 'Listeners[0].{Port:Port,Action:DefaultActions[0].Type,TG:DefaultActions[0].ForwardConfig.TargetGroups[0].TargetGroupArn}'

      - name: Ensure TG health check uses /healthz
        run: |
          set -euo pipefail
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"
          aws elbv2 modify-target-group \
            --target-group-arn "$TG_ARN" \
            --health-check-path "/healthz" \
            --health-check-protocol "HTTP" \
            --health-check-port "traffic-port" \
            --health-check-interval-seconds 10 \
            --health-check-timeout-seconds 5 \
            --healthy-threshold-count 2 \
            --unhealthy-threshold-count 2 \
            --matcher HttpCode=200-399
          echo "[INFO] set health check path to /healthz (200-399)"

      - name: Wait target healthy (custom loop)
        run: |
          set -euo pipefail
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"
          PORT="${{ env.CONTAINER_PORT }}"
          TASK_IP="${{ steps.ecsinfo.outputs.task_ip }}"
          deadline=$((SECONDS+120))
          while :; do
            state=$(aws elbv2 describe-target-health \
              --target-group-arn "$TG_ARN" \
              --targets "Id=$TASK_IP,Port=$PORT" \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text 2>/dev/null || true)
            echo "[INFO] target state = $state"
            [ "$state" = "healthy" ] && break
            [ $SECONDS -gt $deadline ] && { echo "[FATAL] Target not healthy in time"; exit 1; }
            sleep 2
          done
          echo "[INFO] healthy OK"

      - name: Dump LB wiring on failure
        if: failure()
        run: |
          mkdir -p evidence
          aws elbv2 describe-listeners --load-balancer-arn "${{ steps.albinfo.outputs.alb_arn }}" \
            > evidence/$(date +%Y%m%d_%H%M%S)_listeners.json || true
          aws elbv2 describe-target-health --target-group-arn "${{ steps.outs.outputs.tg_arn }}" \
            > evidence/$(date +%Y%m%d_%H%M%S)_tg_health.json || true

      - name: Smoke hit /healthz and /dbcheck
        run: |
          set -euo pipefail
          mkdir -p evidence
          DNS="${{ steps.outs.outputs.alb_dns }}"
          TS=$(date +%Y%m%d_%H%M%S)

          curl -si "http://$DNS/healthz" \
            | tee "evidence/${TS}_healthz.log"

          curl -si "http://$DNS/dbcheck" \
            | tee "evidence/${TS}_dbcheck.log"

      - name: Dump target health on failure
        if: failure()
        run: |
          mkdir -p evidence
          aws elbv2 describe-target-health --target-group-arn "${{ steps.outs.outputs.tg_arn }}" \
            > "evidence/$(date +%Y%m%d_%H%M%S)_tg_health_on_fail.json" || true

      - name: Upload smoke evidence
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-${{ github.run_id }}
          path: |
            evidence/
            infra/20-alb/terraform.tfstate

      - name: Save outputs artifact
        uses: actions/upload-artifact@v4
        with:
          name: alb-smoke-artifacts
          path: |
            infra/20-alb/terraform.tfstate
            evidence/*.log

      - name: Revoke ALB -> ECS task SG ingress (cleanup)
        if: always()
        run: |
          set -euo pipefail
          ALB_SG="${{ steps.outs.outputs.alb_sg_id || '' }}"
          TASK_SG="${{ steps.outs.outputs.task_sg_id || '' }}"
          PORT="${{ env.CONTAINER_PORT }}"

          if [ -z "$ALB_SG" ] || [ -z "$TASK_SG" ]; then
            echo "[WARN] skip revoke: ALB_SG or TASK_SG empty"
            exit 0
          fi

          echo "[INFO] revoking $ALB_SG -> $TASK_SG tcp/$PORT"

          aws ec2 revoke-security-group-ingress \
            --group-id "$TASK_SG" \
            --ip-permissions "IpProtocol=tcp,FromPort=$PORT,ToPort=$PORT,UserIdGroupPairs=[{GroupId=$ALB_SG}]"

      - name: Terraform destroy (always)
        if: always()
        working-directory: infra/20-alb
        run: terraform destroy -auto-approve -var-file=dev.auto.tfvars