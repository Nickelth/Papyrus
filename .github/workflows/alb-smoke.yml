name: Papyrus Smoke
on: workflow_dispatch
permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  VPC_ID: ${{ secrets.VPC_ID }}
  PUBLIC_SUBNET_IDS_JSON: ${{ secrets.PUBLIC_SUBNET_IDS }}
  ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
  ECS_SERVICE: ${{ vars.ECS_SERVICE }}
  CONTAINER_PORT: ${{ vars.CONTAINER_PORT }}

jobs:
  smoke:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: AWS creds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Preflight App Health Check
        run: |
          python - <<'PY'
          from papyrus.preflight_app import create_app_skeleton

          app = create_app_skeleton()
          routes = sorted([r.rule for r in app.url_map.iter_rules()])
          print("ROUTES:", routes)

          assert "/dbcheck" in routes, "dbcheck missing"
          assert "/healthz" in routes, "healthz missing"
          PY
          
      - name: Preflight and connection information drift detection
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail

          SEC_JSON=$(aws secretsmanager get-secret-value \
            --secret-id papyrus/prd/db \
            --region "$AWS_REGION" \
            --query SecretString \
            --output text)

          EP=$(aws rds describe-db-instances \
            --db-instance-identifier papyrus-pg16-dev \
            --region "$AWS_REGION" \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text)

          PORT=$(aws rds describe-db-instances \
            --db-instance-identifier papyrus-pg16-dev \
            --region "$AWS_REGION" \
            --query 'DBInstances[0].Endpoint.Port' \
            --output text)

          SEC_HOST=$(echo "$SEC_JSON" | jq -r .host)
          SEC_PORT=$(echo "$SEC_JSON" | jq -r .port)

          echo "[INFO] SEC_HOST=$SEC_HOST RDS_HOST=$EP"
          echo "[INFO] SEC_PORT=$SEC_PORT RDS_PORT=$PORT"

          test "$SEC_HOST" = "$EP"   || { echo "FATAL: RDS endpoint drift"; exit 1; }
          test "$SEC_PORT" = "$PORT" || { echo "FATAL: RDS port drift"; exit 1; }

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5
          terraform_wrapper: false

      - name: Write tfvars (runtime only)
        working-directory: infra/20-alb
        run: |
          cat > dev.auto.tfvars <<'TFV'
          vpc_id            = ${{ env.VPC_ID }}
          PUBLIC_SUBNET_ids = ${{ env.PUBLIC_SUBNET_IDS_JSON }}
          container_port    = 5000
          allow_cidrs       = ["0.0.0.x/0"]
          ecs_tasks_sg_id   = "${{ secrets.ECS_TASK_SG_ID }}"
          TFV

      - name: Terraform apply (ALB/TG only)
        working-directory: infra/20-alb
        env:
          TF_IN_AUTOMATION: "1"
        run: |
          terraform init -input=false -upgrade=false
          terraform validate
          terraform apply -auto-approve -var-file=dev.auto.tfvars

      - name: Export outputs
        id: outs
        working-directory: infra/20-alb
        run: |
          set -euo pipefail

          ALB_DNS=$(terraform output -raw alb_dns_name)
          TG_ARN=$(terraform output -raw tg_arn)
          ALB_SG=$(terraform output -raw alb_sg_id)
          TASK_SG="${{ secrets.ECS_TASK_SG_ID }}"

          test -n "$ALB_SG"  || { echo "FATAL: alb_sg_id empty"; exit 1; }
          test -n "$TASK_SG" || { echo "FATAL: task_sg_id empty (check secret ECS_TASK_SG_ID)"; exit 1; }

          echo "alb_dns=$ALB_DNS"    >> $GITHUB_OUTPUT
          echo "tg_arn=$TG_ARN"      >> $GITHUB_OUTPUT
          echo "alb_sg_id=$ALB_SG"   >> $GITHUB_OUTPUT
          echo "task_sg_id=$TASK_SG" >> $GITHUB_OUTPUT

      - name: Resolve ALB and listener ARNs
        id: albinfo
        run: |
          set -euo pipefail
          DNS="${{ steps.outs.outputs.alb_dns }}"
          # DNS から ALB ARN を引く
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?DNSName=='$DNS'].LoadBalancerArn" \
            --output text)
          test -n "$ALB_ARN" || { echo "[FATAL] ALB ARN not found by DNS=$DNS"; exit 1; }
          echo "alb_arn=$ALB_ARN" >> $GITHUB_OUTPUT

          # 既存の HTTP:80 リスナーを探す（無ければ空文字）
          LISTENER_ARN=$(aws elbv2 describe-listeners \
            --load-balancer-arn "$ALB_ARN" \
            --query "Listeners[?Protocol=='HTTP' && Port==\`80\`][0].ListenerArn" \
            --output text 2>/dev/null || true)
          if [ "$LISTENER_ARN" = "None" ] || [ -z "$LISTENER_ARN" ]; then
            LISTENER_ARN=""
          fi
          echo "listener_arn=$LISTENER_ARN" >> $GITHUB_OUTPUT
          echo "[INFO] ALB_ARN=$ALB_ARN LISTENER_ARN=${LISTENER_ARN:-<none>}"

      - name: Save outputs artifact
        uses: actions/upload-artifact@v4
        with:
          name: alb-outputs
          path: |
            infra/20-alb/terraform.tfstate

      - name: ECS task inspect (get IP and SG)
        id: ecsinfo
        run: |
          set -euo pipefail
          CLUSTER="${{ env.ECS_CLUSTER }}"
          SERVICE="${{ env.ECS_SERVICE }}"
          REGION="${{ env.AWS_REGION }}"

          TASK_ARN=$(aws ecs list-tasks \
            --cluster "$CLUSTER" \
            --service-name "$SERVICE" \
            --desired-status RUNNING \
            --region "$REGION" \
            --query 'taskArns[0]' \
            --output text)

          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
            echo "[FATAL] no RUNNING task found in cluster=$CLUSTER service=$SERVICE" >&2
            exit 1
          fi
          echo "TASK_ARN=$TASK_ARN"

          ENI_ID=$(aws ecs describe-tasks \
            --cluster "$CLUSTER" \
            --tasks "$TASK_ARN" \
            --region "$REGION" \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)

          TASK_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids "$ENI_ID" \
            --region "$REGION" \
            --query 'NetworkInterfaces[0].PrivateIpAddress' \
            --output text)

          ECS_TASK_SG=$(aws ec2 describe-network-interfaces \
            --network-interface-ids "$ENI_ID" \
            --region "$REGION" \
            --query 'NetworkInterfaces[0].Groups[0].GroupId' \
            --output text)

          echo "task_arn=$TASK_ARN"        >> $GITHUB_OUTPUT
          echo "task_ip=$TASK_IP"          >> $GITHUB_OUTPUT
          echo "ecs_task_sg=$ECS_TASK_SG"  >> $GITHUB_OUTPUT

      - name: Authorize ALB -> ECS task SG ingress
        run: |
          set -euo pipefail
          REGION="${{ env.AWS_REGION }}"
          ALB_SG="${{ steps.outs.outputs.alb_sg_id }}"
          ECS_TASK_SG="${{ steps.ecsinfo.outputs.ecs_task_sg }}"

          echo "[INFO] authorizing $ALB_SG -> $ECS_TASK_SG tcp/5000"

          set +e
          OUT=$(aws ec2 authorize-security-group-ingress \
            --group-id "$ECS_TASK_SG" \
            --region "$REGION" \
            --ip-permissions "IpProtocol=tcp,FromPort=5000,ToPort=5000,UserIdGroupPairs=[{GroupId=$ALB_SG}]" \
            2>&1)
          RC=$?
          set -e

          if [ $RC -ne 0 ]; then
            echo "$OUT" | grep -q 'InvalidPermission.Duplicate'
            if [ $? -eq 0 ]; then
              echo "[WARN] ingress already existed, continuing"
            else
              echo "$OUT" >&2
              echo "[FATAL] unexpected error from authorize-security-group-ingress (code $RC)" >&2
              exit $RC
            fi
          else
            echo "[INFO] ingress created"
          fi

      - name: Assert ALB subnets cover task AZ
        run: |
          set -euo pipefail
          ALB_DNS="${{ steps.outs.outputs.alb_dns }}"
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"

          # ALB ARN -> 有効AZ
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?DNSName=='$ALB_DNS'].LoadBalancerArn" --output text)
          ALB_ZONES=$(aws elbv2 describe-load-balancers --load-balancer-arns "$ALB_ARN" \
            --query 'LoadBalancers[0].AvailabilityZones[].ZoneName' --output text)

          # タスクのAZ
          CLUSTER="${{ env.ECS_CLUSTER }}"
          SERVICE="${{ env.ECS_SERVICE }}"
          TASK_ARN=$(aws ecs list-tasks --cluster "$CLUSTER" --service-name "$SERVICE" \
            --desired-status RUNNING --query 'taskArns[0]' --output text)
          ENI_ID=$(aws ecs describe-tasks --cluster "$CLUSTER" --tasks "$TASK_ARN" \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
          TASK_AZ=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" \
            --query 'NetworkInterfaces[0].AvailabilityZone' --output text)

          echo "[INFO] ALB zones: $ALB_ZONES"
          echo "[INFO] TASK az  : $TASK_AZ"

          echo "$ALB_ZONES" | tr '\t' '\n' | grep -qx "$TASK_AZ" || {
            echo "[FATAL] AZ mismatch: ALB not enabled in $TASK_AZ. This causes TargetHealth=unused."
            echo "[HINT] Add a public subnet for $TASK_AZ to PUBLIC_SUBNET_IDS_JSON (infra/20-alb), or pin ECS service to ALB-enabled AZs."
            exit 1
          }

      - name: Register target
        run: |
          set -euo pipefail
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"
          TASK_IP="${{ steps.ecsinfo.outputs.task_ip }}"
          PORT="${{ env.CONTAINER_PORT }}"

          echo "Registering $TASK_IP:$PORT to $TG_ARN"

          aws elbv2 register-targets \
            --target-group-arn "$TG_ARN" \
            --targets "Id=$TASK_IP,Port=$PORT"

      - name: Verify target is registered
        run: |
          set -euo pipefail
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"
          aws elbv2 register-targets \
            --target-group-arn "$TG_ARN" \
            --targets "Id=${{ steps.ecsinfo.outputs.task_ip }},Port=${{ env.CONTAINER_PORT }}"
          # 登録済みターゲット一覧を確認
          aws elbv2 describe-target-health --target-group-arn "$TG_ARN" \
            --query 'TargetHealthDescriptions[].{ip:Target.Id,port:Target.Port,state:TargetHealth.State}' \
            --output table
          COUNT=$(aws elbv2 describe-target-health --target-group-arn "$TG_ARN" \
            --query 'length(TargetHealthDescriptions[])' --output text)
          [ "$COUNT" -ge 1 ] || { echo "[FATAL] No targets in TG after registration"; exit 1; }

      - name: Ensure listener forwards to our TG
        run: |
          set -euo pipefail
          ALB_ARN="${{ steps.albinfo.outputs.alb_arn }}"
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"

          get_listener_arn() {
            aws elbv2 describe-listeners \
              --load-balancer-arn "$ALB_ARN" \
              --query "Listeners[?Protocol=='HTTP' && Port==\`80\`].ListenerArn | [0]" \
              --output text 2>/dev/null | sed 's/^None$//'
          }

          LSN="$(get_listener_arn || true)"

          if [ -z "${LSN:-}" ]; then
            echo "[INFO] No HTTP:80 listener. Creating one."
            set +e
            CREATE_OUT=$(aws elbv2 create-listener \
              --load-balancer-arn "$ALB_ARN" \
              --protocol HTTP --port 80 \
              --default-actions "Type=forward,TargetGroupArn=$TG_ARN" 2>&1)
            RC=$?
            set -e
            if [ $RC -ne 0 ]; then
              echo "$CREATE_OUT" | grep -q "DuplicateListener"
              if [ $? -eq 0 ]; then
                echo "[WARN] DuplicateListener; refetching existing listener"
                sleep 2
                LSN="$(get_listener_arn || true)"
              else
                echo "$CREATE_OUT" >&2
                exit $RC
              fi
            else
              # create-listener の JSON から ARN を抜く
              LSN=$(printf '%s' "$CREATE_OUT" | jq -r '.Listeners[0].ListenerArn' 2>/dev/null || true)
            fi
          fi

          if [ -z "${LSN:-}" ]; then
            echo "[FATAL] Failed to resolve HTTP:80 listener ARN"
            aws elbv2 describe-listeners --load-balancer-arn "$ALB_ARN" || true
            exit 1
          fi

          echo "[INFO] Using LISTENER_ARN=$LSN"

          # 既定アクションの TG を取得（両形対応: TargetGroupArn or ForwardConfig.TargetGroups[0].TargetGroupArn）
          CUR_TG=$(aws elbv2 describe-listeners --listener-arn "$LSN" \
                     --query 'Listeners[0].DefaultActions[0].TargetGroupArn' \
                     --output text 2>/dev/null || true)
          if [ -z "$CUR_TG" ] || [ "$CUR_TG" = "None" ]; then
            CUR_TG=$(aws elbv2 describe-listeners --listener-arn "$LSN" \
                        --query 'Listeners[0].DefaultActions[0].ForwardConfig.TargetGroups[0].TargetGroupArn' \
                        --output text 2>/dev/null || true)
            [ "$CUR_TG" = "None" ] && CUR_TG=""
          fi
          echo "[INFO] Current listener TG=${CUR_TG:-<none>}"

          if [ "$CUR_TG" != "$TG_ARN" ] && [ -n "$TG_ARN" ]; then
            echo "[INFO] Modifying listener to forward to TG=$TG_ARN"
            aws elbv2 modify-listener \
              --listener-arn "$LSN" \
              --default-actions "Type=forward,TargetGroupArn=$TG_ARN" \
              >/dev/null
          else
            echo "[INFO] Listener already forwards to our TG"
          fi

          # 証跡
          aws elbv2 describe-listeners --listener-arn "$LSN" \
            --query 'Listeners[0].{Port:Port,Action:DefaultActions[0].Type}' \
            --output json

      - name: Ensure TG health check uses /healthz
        run: |
          set -euo pipefail
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"
          aws elbv2 modify-target-group \
            --target-group-arn "$TG_ARN" \
            --health-check-path "/healthz" \
            --health-check-protocol "HTTP" \
            --health-check-port "traffic-port" \
            --health-check-interval-seconds 10 \
            --health-check-timeout-seconds 5 \
            --healthy-threshold-count 2 \
            --unhealthy-threshold-count 2 \
            --matcher HttpCode=200-399
          echo "[INFO] set health check path to /healthz (200-399)"

      - name: Wait target healthy (custom loop)
        run: |
          set -euo pipefail
          TG_ARN="${{ steps.outs.outputs.tg_arn }}"
          deadline=$((SECONDS+120))
          while :; do
            STATE=$(aws elbv2 describe-target-health --target-group-arn "$TG_ARN" \
              --query 'TargetHealthDescriptions[0].TargetHealth.State' \
              --output text 2>/dev/null || true)
            echo "[INFO] target state = ${STATE:-<none>}"
            [ "$STATE" = "healthy" ] && break
            [ $SECONDS -gt $deadline ] && { echo "[FATAL] Target not healthy in time"; exit 1; }
            sleep 2
          done
          echo "[INFO] healthy OK"

      - name: Dump TG health and listeners on failure
        if: failure()
        run: |
          mkdir -p evidence
          aws elbv2 describe-target-health --target-group-arn "${{ steps.outs.outputs.tg_arn }}" \
            > evidence/$(date +%Y%m%d_%H%M%S)_tg_health.json || true
          aws elbv2 describe-listeners --load-balancer-arn "${{ steps.albinfo.outputs.alb_arn }}" \
            > evidence/$(date +%Y%m%d_%H%M%S)_listeners.json || true

      - name: Smoke hit /healthz and /dbcheck
        run: |
          set -euo pipefail
          mkdir -p evidence
          DNS="${{ steps.outs.outputs.alb_dns }}"
          TS=$(date +%Y%m%d_%H%M%S)

          curl -si "http://$DNS/healthz" \
            | tee "evidence/${TS}_healthz.log"

          curl -si "http://$DNS/dbcheck" \
            | tee "evidence/${TS}_dbcheck.log"

      - name: Dump target health on failure
        if: failure()
        run: |
          mkdir -p evidence
          aws elbv2 describe-target-health --target-group-arn "${{ steps.outs.outputs.tg_arn }}" \
            > "evidence/$(date +%Y%m%d_%H%M%S)_tg_health_on_fail.json" || true

      - name: Upload smoke evidence
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-${{ github.run_id }}
          path: |
            evidence/
            infra/20-alb/terraform.tfstate

      - name: Save outputs artifact
        uses: actions/upload-artifact@v4
        with:
          name: alb-smoke-artifacts
          path: |
            infra/20-alb/terraform.tfstate
            evidence/*.log

      - name: Revoke ALB -> ECS task SG ingress (cleanup)
        if: always()
        run: |
          set -euo pipefail
          ALB_SG="${{ steps.outs.outputs.alb_sg_id || '' }}"
          TASK_SG="${{ steps.outs.outputs.task_sg_id || '' }}"
          PORT="${{ env.CONTAINER_PORT }}"

          if [ -z "$ALB_SG" ] || [ -z "$TASK_SG" ]; then
            echo "[WARN] skip revoke: ALB_SG or TASK_SG empty"
            exit 0
          fi

          echo "[INFO] revoking $ALB_SG -> $TASK_SG tcp/$PORT"

          aws ec2 revoke-security-group-ingress \
            --group-id "$TASK_SG" \
            --ip-permissions "IpProtocol=tcp,FromPort=$PORT,ToPort=$PORT,UserIdGroupPairs=[{GroupId=$ALB_SG}]"

      - name: Terraform destroy (always)
        if: always()
        working-directory: infra/20-alb
        run: terraform destroy -auto-approve -var-file=dev.auto.tfvars